# Practice Problems: Implicit and Explicit Function Execution Contexts

1. What will the following code output? Try to determine the results without running the code.

   ```js
   function func() {
     return this;
   }
   
   let context = func();
   
   console.log(context);
   ```

   ```
   global object
   ```

   Show Solution

   The global object. In Node, that's `global`; in a browser, that's `window`.

   Since line 5 calls `func` as a function, the implicit context for `func` is the global object, so it returns the global object.

2. What will the following code output? Explain the difference, if any, between this output and that of problem 1.

   ```js
   let obj = {
     func: function() {
       return this;
     },
   };
   
   let context = obj.func();
   
   console.log(context);
   ```

   It outputs the object `obj` because `obj` invokes `func` as a method. The output looks like this in node: 

   ```terminal
   { func: [Function: func] }
   ```

   As a method invocation, it receives the implicit execution context that refers to the object used to invoke it. 

3. What will the following code output?

   ```js
   message = 'Hello from the global scope!';
   
   function deliverMessage() {
     console.log(this.message);
   }
   
   deliverMessage();
   
   let foo = {
     message: 'Hello from the function scope!',
   };
   
   foo.deliverMessage = deliverMessage;
   
   foo.deliverMessage();
   ```

   ```terminal
   "Hello from the global scope!"
   "Hello from the function scope!"
   ```

   On line 13, method  deliverMessage is added to the `foo` function as a property. The method is invoked on line 15, which means the implicit execution method is set to `foo`, the object that invoked the method. This means that when `deliverMessage` function is ran, `this` refers to `foo`.  

   The first log operation is generated by function call `deliverMessage()` on line 7. Since this is a function invocation, the implicit function execution context is set to the global object. The global property `message`, or global variable is referenced on line 4. On line 15, there is a method call `foo.deliverMessage()`. Since the implicit function execution context for method invocation is the calling object, `this` resolves to `foo.message`. 

   Show Solution

   The first `log` operation is generated by the function call, `deliverMessage()` on line 7. Since this is a function invocation, the implicit function execution context is the global object; the global property `message`, which is often called a global variable, is referenced. The second `log` operation is generated by the method call `foo.deliverMessage()` on line 15. Since the implicit function execution context for a method invocation is the calling object, this resolves to `foo.message`

4. What built-in methods have we learned about that we can use to specify a function's execution context explicitly?

   `call()` and `apply()`

   Show Solution

   The Function methods `call` and `apply` let us explicitly set the function execution context.

5. Take a look at the following code snippet. Use `call` to invoke the `add` method but with `foo` as execution context. What will this return?

   ```js
   let foo = {
     a: 1,
     b: 2,
   };
   
   let bar = {
      a: 'abc',
      b: 'def',
      add: function() {
        return this.a + this.b;
      },
   };
   
   ```
   
   ```js
   bar.add.call(foo); // => 3
   ```
   
    Since we invoke `add` by using `call`, the explicit execution context is set to `foo`. 
   
   Show Solution
   
   Since we invoke `call` on `bar.add` with `foo` as the explicit context, the `add` method uses `foo.a` and `foo.b` to determine the results, not `bar.a` and `bar.b`. Thus, the return value is `3`.